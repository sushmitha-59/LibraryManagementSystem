package com.example.minor_project.Service;

import com.example.minor_project.model.Users;
import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.io.Decoders;
import io.jsonwebtoken.security.Keys;
import org.apache.commons.codec.binary.Base64;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import java.security.NoSuchAlgorithmException;
import java.util.Date;
import java.util.HashMap;

@Service
public class JWTservice {
    private String secretKey="";

    @Value("${spring.login.timeout}")
    int timeout;

    public JWTservice()
    {
        //everytime user logs in , this service gets initialised for them , so everytime new key gets generated
        //generate some random valid length key
        try {
            //choose algorithm
            KeyGenerator keyGen=KeyGenerator.getInstance("HmacSHA256");
            //now generate some random hash secret key from the cryptographic hmac sha algorithm
            SecretKey random_hash=keyGen.generateKey();
            //random is in byte format , basically cryptographic generations/operations work with bytes
            //but its not human readable and cannot pass easily to other files
            //so we have to keep it safe , so encode it to string and store safely
            //whenever needed decode it ,again crypto works only with bytes
            //later we will decode to convert it into bytes[] , so now we have to encode
            //when generating the secret key , choose algo , generate random key , then encode it to store it in safer format
            //when generating the key ,  key->bytes->decode
            secretKey= Base64.encodeBase64String(random_hash.getEncoded());
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException(e);
        }
    }
    public String generateToken(Users user) {
        //so for username it will generate token and that user can send requests until that token expires
        //token contains header , payload(user info and claims) , signature(which hash algorithm to use)
        HashMap<String , Object> claims_map=new HashMap<>();
        claims_map.put("id",user.getId());
        claims_map.put("rawauthorities",user.getRawauthorities());
        System.out.println(user.getRawauthorities());
        //add all the data like expiration ,issue time,
        return Jwts.builder()  //start building a token
                .claims() //claims part
                .add(claims_map) //add the custom claims
                .subject(user.getUsername()) //subject is used for verifying
                .issuedAt(new Date(System.currentTimeMillis())) //this will be in claims
                .expiration(new Date(System.currentTimeMillis()+ 1000L * 60 * timeout)) //valid for 2 minute . will be in claims adding till to claims
                .and() //claims adding got ended
                .signWith(getJWTKey()) //add signature ,like a digital signature , sign with the signing key generated by the crypto algorithm
                .compact();//then turn it into string format
    }

    private SecretKey getJWTKey() {
        //convert the private key string to the Byte code using base64 , cryptographic operations are allowed only with bytes
        byte[] bytes= Decoders.BASE64.decode(this.secretKey);
        return Keys.hmacShaKeyFor(bytes); //using hmac sha algorithm to create a usable signing key
    }

    public String extractUsername(String jwtToken) {
        Claims claims=getClaimsOutOfToken(jwtToken);//we will get claims here
        //now return the subject
        return claims.getSubject();
    }

    private Claims getClaimsOutOfToken(String jwtToken) {
        return Jwts.parser()
                .verifyWith(getJWTKey())
                .build()
                .parseSignedClaims(jwtToken)
                .getPayload();
    }

    public boolean expiredToken(String jwtToken) {
        Claims claims=getClaimsOutOfToken(jwtToken);//we will get claims here
        //get the token expiration time and compare it with the current time
        return System.currentTimeMillis() >= claims.getExpiration().getTime();
    }
}
